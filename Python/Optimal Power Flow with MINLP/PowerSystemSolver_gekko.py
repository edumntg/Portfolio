from PowerSystem import *
from gekko import GEKKO
import pandas as pd

class PowerSystemSolver_gekko(object):

    def __init__(self, system: PowerSystem):
        self.system = system
        self.opf_solved = False
        self.pf_solved = False
        self.opf_solution = None
        self.opf_solver = None
        self.pf_solution = None

    def opf(self):
        if not self.system:
            raise "No PowerSystem object declared"
        
        # Construct Ybus
        self.system.construct_ybus()

        # Construct Pyomo model
        model = self.__construct_optim_model()

        # Construct solver
        solver = self.__construct_solver()

        # Now, solve
        #results = solver.solve(model, mip_solver='glpk', nlp_solver='ipopt', tee = True)
        results = solver.solve(model, tee = True)
        self.opf_solution = results

        return self.opf_solution

    def __construct_optim_model(self):
        m = GEKKO()
        m.options.SOLVER = 1 # apopt for MINLP

        # optional solver settings with APOPT
        # m.solver_options = ['minlp_maximum_iterations 500', \
        #                     # minlp iterations with integer solution
        #                     'minlp_max_iter_with_int_sol 10', \
        #                     # treat minlp as nlp
        #                     'minlp_as_nlp 0', \
        #                     # nlp sub-problem max iterations
        #                     'nlp_maximum_iterations 50', \
        #                     # 1 = depth first, 2 = breadth first
        #                     'minlp_branch_method 1', \
        #                     # maximum deviation from whole number
        #                     'minlp_integer_tol 0.05', \
        #                     # covergence tolerance
        #                     'minlp_gap_tol 0.01']

        # Voltage variables
        self.V = m.Array(m.Var, dim = (self.system.n_buses,), lb = 0.95, ub = 1.05, value = 1.0)

        # Angle variables
        self.theta = m.Array(m.Var, dim = (self.system.n_buses,), lb = -np.pi, ub = np.pi, value = np.pi)

        # Active power generated
        self.Pgen = m.Array(m.Var, dim = (self.system.n_gens,))

        # Reactive power generated
        self.Qgen = m.Array(m.Var, dim = (self.system.n_gens,))

        # Flow through lines
        self.Pflow = m.Array(m.Var, dim = (self.system.n_buses, self.system.n_buses))
        self.Qflow = m.Array(m.Var, dim = (self.system.n_buses, self.system.n_buses))

        # On/Off for lines
        self.l = m.Array(m.Var, dim = (self.system.n_lines,), lb = 0, ub = 1, value = 1, integer = True)

        # Create objective function
        m.Obj(self.__optim_objective())

        # Min active power generated by each generator
        m.Equations(
            [
                self.__optim_constr_gen_Pmin(gen) for gen in self.system.generators
            ]
        )

        # Max active power generated by each generator
        m.Equations(
            [
                self.__optim_constr_gen_Pmax(gen) for gen in self.system.generators
            ]
        )

        # Min reactive power generated by each generator
        m.Equations(
            [
                self.__optim_constr_gen_Qmin(gen) for gen in self.system.generators
            ]
        )

        # Max reactive power generated by each generator
        m.Equations(
            [
                self.__optim_constr_gen_Qmax(gen) for gen in self.system.generators
            ]
        )

        # Kirchoff law for active power
        m.Equations([
            self.__optim_constr_kirchoff_P(bus) for bus in self.system.buses
        ])
        
        # Kirchoff law for reactive power
        m.Equations([
            self.__optim_constr_kirchoff_Q(bus) for bus in self.system.buses
        ])

        # Equations for active-power flow through lines
        m.Equations([
            self.__optim_constr_line_P_fromto(line, m) for line in self.system.lines
        ])
        m.Equations([
            self.__optim_constr_line_P_tofrom(line, m) for line in self.system.lines
        ])

        # # Equations for reactive-power flow through lines
        m.Equations([
            self.__optim_constr_line_Q_fromto(line, m) for line in self.system.lines
        ])
        m.Equations([
            self.__optim_constr_line_Q_tofrom(line, m) for line in self.system.lines
        ])

        # Transmission lines limits
        m.Equations([
            self.__optim__constr_line_max_mva_fromto(line) for line in self.system.lines
        ])
        m.Equations([
            self.__optim__constr_line_max_mva_tofrom(line) for line in self.system.lines
        ])

        self.m = m

        return self.m

    def opf(self, disp = True):
        if not self.system:
            raise "No PowerSystem object declared"
        
        # Construct Ybus
        self.system.construct_ybus()

        # Construct Pyomo model
        model = self.__construct_optim_model()

        # Now, solve
        model.solve(disp = disp)
        self.opf_solved = True

    def __optim_objective(self):
        total_cost = 0.0

        for gen in self.system.generators:
            total_cost += gen.cost(self.Pgen[gen.id])

        return total_cost

    def opf_results(self):
        if not self.opf_solved:
            raise "OPF not solved yet"
        
        # Create dataframes for results
        data = []
        for bus in self.system.buses:
            # Append results as: V, theta, Pload, Qload, Pgen, Qgen
            row = [bus.id, self.V[bus.id].value[0], self.theta[bus.id].value[0], bus.Pload, bus.Qload]
            Pgen = np.sum([self.Pgen[gen.bus] for gen in self.system.generators if gen.bus == bus.id])
            Qgen = np.sum([self.Qgen[gen.bus] for gen in self.system.generators if gen.bus == bus.id])
            row += [Pgen, Qgen]

            data.append(row)
        
        # Create DataFrame
        bus_df = pd.DataFrame(data, columns = ['id', 'V', 'theta', 'Pload', 'Qload', 'Pgen', 'Qgen'])

        # Create generators DataFrame
        data = []
        for gen in self.system.generators:
            row = [gen.id, self.Pgen[gen.id][0], self.Qgen[gen.id][0], gen.cost(self.Pgen[gen.id][0]), gen.Pmin, gen.Pmax, gen.Qmin, gen.Qmax]
            data.append(row)
        
        gen_df = pd.DataFrame(data, columns = ['id', 'Pgen', 'Qgen', 'cost', 'Pmin', 'Pmax', 'Qmin', 'Qmax'])

        #Create lines DataFrame
        data = []
        for line in self.system.lines:
            i = line.from_bus
            k = line.to_bus
            row = [line.id, i, k, self.l[line.id].value[0], self.Pflow[i,k][0], self.Pflow[k,i][0], self.Qflow[i,k][0], self.Qflow[k,i][0], line.S(self.Pflow[i,k][0], self.Qflow[i,k][0]), line.Plosses(self.Pflow[i,k][0], self.Pflow[k,i][0]), line.mva]
            data.append(row)
        
        lines_df = pd.DataFrame(data, columns = ['id', 'from', 'to', 'active', 'Pout', 'Pin', 'Qout', 'Qin', 'S', 'Ploss', 'mva'])

        return bus_df, gen_df, lines_df
    def __optim_constr_gen_Pmin(self, gen):
        return self.Pgen[gen.id] >= gen.Pmin
    
    def __optim_constr_gen_Pmax(self, gen):
        return self.Pgen[gen.id] <= gen.Pmax
    
    def __optim_constr_gen_Qmin(self, gen):
        return self.Qgen[gen.id] >= gen.Qmin
    
    def __optim_constr_gen_Qmax(self, gen):
        return self.Qgen[gen.id] <= gen.Qmax
    
    def __optim_constr_kirchoff_P(self, bus):
        Pflow = 0.0
        Pgen = 0

        # Find if there is a generator connected at this bus
        for gen in self.system.generators:
            if gen.bus == bus.id:
                Pgen += self.Pgen[gen.id]

        for line in self.system.lines:
            if line.from_bus == bus.id:
                Pflow += self.Pflow[line.from_bus, line.to_bus]

        for line in self.system.lines:
            if line.to_bus == bus.id:
                Pflow += self.Pflow[line.to_bus, line.from_bus]

        return Pgen == bus.Pload + Pflow
    
    def __optim_constr_kirchoff_Q(self, bus):
        Qflow = 0.0
        Qgen = 0

        # Find if there is a generator connected at this bus
        for gen in self.system.generators:
            if gen.bus == bus.id:
                Qgen += self.Qgen[gen.id]

        for line in self.system.lines:
            if line.from_bus == bus.id:
                Qflow += self.Qflow[line.from_bus, line.to_bus]

        for line in self.system.lines:
            if line.to_bus == bus.id:
                Qflow += self.Qflow[line.to_bus, line.from_bus]

        return Qgen == bus.Qload + Qflow
    
    def __optim_constr_line_P_fromto(self, line, m):
        i = line.from_bus
        k = line.to_bus

        return self.Pflow[i,k] == self.l[line.id]*((-self.system.G[i,k] + self.system.g[i,k])*self.V[i]**2 + self.V[i]*self.V[k]*(self.system.G[i,k]*m.cos(self.theta[i] - self.theta[k]) + self.system.B[i,k]*m.sin(self.theta[i] - self.theta[k])))
    
    def __optim_constr_line_P_tofrom(self, line, m):
        i = line.to_bus
        k = line.from_bus

        return self.Pflow[i,k] == self.l[line.id]*((-self.system.G[i,k] + self.system.g[i,k])*self.V[i]**2 + self.V[i]*self.V[k]*(self.system.G[i,k]*m.cos(self.theta[i] - self.theta[k]) + self.system.B[i,k]*m.sin(self.theta[i] - self.theta[k])))
    
    def __optim_constr_line_Q_fromto(self, line, m):
        i = line.from_bus
        k = line.to_bus

        return self.Qflow[i,k] == self.l[line.id]*((self.system.B[i,k] - self.system.b[i,k])*self.V[i]**2 + self.V[i]*self.V[k]*(-self.system.B[i,k]*m.cos(self.theta[i] - self.theta[k]) + self.system.G[i,k]*m.sin(self.theta[i] - self.theta[k])))
    
    def __optim_constr_line_Q_tofrom(self, line, m):
        i = line.to_bus
        k = line.from_bus

        return self.Qflow[i,k] == self.l[line.id]*((self.system.B[i,k] - self.system.b[i,k])*self.V[i]**2 + self.V[i]*self.V[k]*(-self.system.B[i,k]*m.cos(self.theta[i] - self.theta[k]) + self.system.G[i,k]*m.sin(self.theta[i] - self.theta[k])))
    
    def __optim__constr_line_max_mva_fromto(self, line):
        # Get apparent power

        return self.Pflow[line.from_bus, line.to_bus]**2 + self.Qflow[line.from_bus, line.to_bus]**2 <= line.mva**2
    
    def __optim__constr_line_max_mva_tofrom(self, line):
        # Get apparent power

        return self.Pflow[line.to_bus, line.from_bus]**2 + self.Qflow[line.to_bus, line.from_bus]**2 <= line.mva**2
    
      
        